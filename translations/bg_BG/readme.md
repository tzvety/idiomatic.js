# Писане на идиоматичен JavaScript код


## This is a living document and new ideas for improving the code around us are always welcome. Contribute: fork, clone, branch, commit, push, pull request.

* Rick Waldron [@rwaldron](http://twitter.com/rwaldron), [github](https://github.com/rwaldron)
* Mathias Bynens [@mathias](http://twitter.com/mathias), [github](https://github.com/mathiasbynens)
* Schalk Neethling [@ossreleasefeed](http://twitter.com/ossreleasefeed), [github](https://github.com/ossreleasefeed/)
* Kit Cambridge  [@kitcambridge](http://twitter.com/kitcambridge), [github](https://github.com/kitcambridge)
* Raynos  [github](https://github.com/Raynos)
* Matias Arriola [@MatiasArriola](https://twitter.com/MatiasArriola), [github](https://github.com/MatiasArriola/)
* John Fischer [@jfroffice](https://twitter.com/jfroffice), [github](https://github.com/jfroffice/)
* Idan Gazit [@idangazit](http://twitter.com/idangazit), [github](https://github.com/idan)
* Leo Balter [@leobalter](http://twitter.com/leobalter), [github](https://github.com/leobalter)
* Breno Oliveira [@garu_rj](http://twitter.com/garu_rj), [github](https://github.com/garu)
* Leo Beto Souza [@leobetosouza](http://twitter.com/leobetosouza), [github](https://github.com/leobetosouza)
* Ryuichi Okumura [@okuryu](http://twitter.com/okuryu), [github](https://github.com/okuryu)
* Pascal Precht [@PascalPrecht](http://twitter.com/PascalPrecht), [github](https://github.com/pascalprecht)
* EngForDev [engfordev](http://www.opentutorials.org/course/167/1363) - Hwan Min Hong / MinTaek Kwon [@leoinsight](http://twitter.com/leoinsight) / Tw Shim [@marocchino](http://twitter.com/marocchino), [github](https://github.com/marocchino) / Nassol Kim [@nassol99](http://twitter.com/nassol99), [github](https://github.com/nassol) / Juntai Park [@rkJun](http://twitter.com/rkJun), [github](https://github.com/rkJun) / Minkyu Shim / Gangmin Won / Justin Yoo [@justinchronicle](http://twitter.com/justinchronicle) / Daeyup Lee
* Marco Trulla [@marcotrulla](http://twitter.com/marcotrulla), [github](https://github.com/Ragnarokkr)
* Alex Navasardyan [@alexnavasardyan](http://twitter.com/alexnavasardyan), [github](https://github.com/2k00l)
* Mihai Paun [@mihaipaun](http://twitter.com/mihaipaun), [github](https://github.com/mihaipaun)
* Evgeny Mandrikov [@\_godin\_](http://twitter.com/_godin_), [github](https://github.com/Godin)
* Sofish Lin [@sofish](http://twitter.com/sofish), [github](https://github.com/sofish)
* Дејан Димић [@dejan_dimic](http://twitter.com/dejan_dimic), [github](https://github.com/rubystream)
* Miloš Gavrilović [@gavrisimo](http://twitter.com/gavrisimo), [github](https://github.com/gavrisimo)
* Firede [@firede](https://twitter.com/firede) [github](https://github.com/firede)
* monkadd [github](https://github.com/monkadd)
* Stephan Lindauer [@stephanlindauer](http://twitter.com/stephanlindauer), [github](https://github.com/stephanlindauer)
* Thomas P [@dragon5689](https://twitter.com/dragon5689) [github](https://github.com/dragon5689)
* Yotam Ofek [@yotamofek](https://twitter.com/yotamofek) [github](https://github.com/yotamofek)
* Aleksandr Filatov [@greybax](http://twitter.com/greybax), [github](https://github.com/greybax)
* Duc Nguyen [@ducntq](https://twitter.com/ducntq), [github](https://github.com/ducntq)
* James Young [@jamsyoung](http://twitter.com/jamsyoung), [github](https://github.com/jamsyoung)
* Hao-Wei Jeng [@l0ckys](http://twitter.com/l0ckys), [github](https://github.com/lockys)  
* Richard Gibson [@gibson042](http://twitter.com/gibson042), [github](https://github.com/gibson042)  
* Fesuy [github](https://github.com/fesuydev)  
* Stephane Moreau [github](https://github.com/stmoreau)  
* Tsvetana Nikova [github](https://github.com/tzvety)  


## Написаният код винаги трябва да изглежда така, сякаш е създаден от един човек, независимо колко хора са работили по него.

### Списъкът по-долу е обоснован на практическите ми методи, които съм използвал като автор на код; участниците в проекти, които съм създал също използват описаните насоки.

### Нямам намерение да налагам моите предпочитания върху кода на други хора или проекти; ако съществува в момента популярен стил, той трябва да се респектира.


> ### "В повечето случаи, аргументите върху начина на писане на код са безпочвени. Трябва да има номенклатура, която да се следва."
>_Rebecca_ _Murphey_

&nbsp;

> ### "Един от основните принципи да бъдеш добра част от успешен проект е осъзднаването, че писането на код "за себе си" е лоша идея. Ако хиляди потребтители ползват кода ти, тогава го пиши максимално чисто, не според предпочитанията си и не за да покажеш умния си подход в спецификациите."
>_Idan_ _Gazit_


## Преводи

* [German](https://github.com/rwldrn/idiomatic.js/tree/master/translations/de_DE)
* [French](https://github.com/rwldrn/idiomatic.js/tree/master/translations/fr_FR)
* [Spanish](https://github.com/rwldrn/idiomatic.js/tree/master/translations/es_ES)
* [Portuguese - Brazil](https://github.com/rwldrn/idiomatic.js/tree/master/translations/pt_BR)
* [Korean](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ko_KR)
* [日本語](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ja_JP)
* [Italian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/it_IT)
* [Russian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ru_RU)
* [Romanian](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ro_RO)
* [简体中文](https://github.com/rwldrn/idiomatic.js/tree/master/translations/zh_CN)
* [Serbian - cyrilic alphabet](https://github.com/rwldrn/idiomatic.js/tree/master/translations/ср_СР)
* [Serbian - latin alphabet](https://github.com/rwldrn/idiomatic.js/tree/master/translations/sr_SR)
* [繁體中文](https://github.com/rwaldron/idiomatic.js/tree/master/translations/zh_TW)  
* [Indonesian](https://github.com/rwaldron/idiomatic.js/tree/master/translations/id_ID)  
* [Greek](https://github.com/rwaldron/idiomatic.js/tree/master/translations/gr_GR)  
* [Български](https://github.com/rwaldron/idiomatic.js/tree/master/translations/bg_BG)  

## Важни връзки:

### Инструменти за писане на качествен код, ресурси и референции

 * [JavaScript Plugin](http://docs.codehaus.org/display/SONAR/JavaScript+Plugin) за [Sonar](http://www.sonarsource.org/)
 * [Plato](https://github.com/es-analysis/plato)
 * [jsPerf](http://jsperf.com/)
 * [jsFiddle](http://jsfiddle.net/)
 * [Codepen](http://codepen.io/)
 * [jsbin](http://jsbin.com/)
 * [JavaScript Lint (JSL)](http://javascriptlint.com/)
 * [jshint](http://jshint.com/)
 * [jslint](http://jslint.org/)
 * [eslint](http://eslint.org/)
 * [jscs](https://www.npmjs.org/package/jscs)
 * [jscodesniffer](https://www.npmjs.org/package/jscodesniffer)
 * [Editorconfig](http://editorconfig.org/)
 * [Hound](https://houndci.com/)

## Бъди разумен

### [Анотиран ECMAScript 5.1](http://es5.github.com/)
### [EcmaScript спецификация, 5.1 Edition](http://ecma-international.org/ecma-262/5.1/)

Списъкът от връзки тук трябва е 1) незавършен, и 2) *ИЗИСКВА ЧЕТЕНЕ*. Аз не винаги съм съгласен със стила на авторите по-долу, но едно е сигурно - те са последователни.

 * [Baseline For Front End Developers: 2015](http://rmurphey.com/blog/2015/03/23/a-baseline-for-front-end-developers-2015/)
 * [Eloquent JavaScript](http://eloquentjavascript.net/)
 * [JavaScript, JavaScript](http://javascriptweblog.wordpress.com/)
 * [Adventures in JavaScript Development](http://rmurphey.com/)
 * [Perfection Kills](http://perfectionkills.com/)
 * [Douglas Crockford's Wrrrld Wide Web](http://www.crockford.com)
 * [JS Assessment](https://github.com/rmurphey/js-assessment)




### Build & Deployment Процес

Проектите винаги трябва да включват средства които да форматират, тестват и сравняват кода при подготовката му за потребителска употреба. Не забравяйте за [grunt](https://github.com/gruntjs/grunt) на Ben Alman.




### Тестове

Всички проекти _трябва_ да включват някаква форма на тестване. Потребителските демота НЕ СА реални "тестове". Изберете подходяща библиотека за тестване според личните ви предпочитания. Нито една от посочените не би могла да се счита за по-добра от останалите.

 * [QUnit](http://github.com/jquery/qunit)
 * [Jasmine](https://github.com/pivotal/jasmine)
 * [Vows](https://github.com/cloudhead/vows)
 * [Mocha](https://github.com/visionmedia/mocha)
 * [Hiro](http://hirojs.com/)
 * [JsTestDriver](https://code.google.com/p/js-test-driver/)
 * [Buster.js](http://busterjs.org/)
 * [Sinon.js](http://sinonjs.org/)
 * [Tape](https://github.com/substack/tape)

## Съдържание

 * [Отстояния](#whitespace)
 * [Красив синтаксис](#spacing)
 * [Правопис (jQuery Core Style Guidelines)](#type)
 * [Условни Оценки](#cond)
 * [Практически стил](#practical)
 * [Именуване](#naming)
 * [Други](#misc)
 * [Локални и Хост обекти](#native)
 * [Коментари](#comments)
 * [Един езиков код](#language)



------------------------------------------------


## Предговор

Следващите секции регламентират _логично_ ръководство за стилизирано писане на модерен JavaScript. Те не трябва да бъдат считани за нормативни. Най-важната част е **последователността**. Какъвто и стил на писане да изберете, важното е да го следвате. Добавете връзка към този документ, за да декларирате отношението си към последователно написиня код, неговата четимост и ползваемост.





## Манифест на стила


1. <a name="whitespace">Отстояния</a>
  - Никога не смесвайте интервалите с табулатури.
  - Когато стартирате проект, преди да започнете писането на код, изберете между soft indents (интервали) и tabs. Разглеждайте това като своеобразен **закон**.
      - За повече четимост, винаги препоръчвам отстоянията да са 2 символа до 2 символа и &mdash;. Това означава два интервала или два интервала представляващи един реален tab.
  - Ако редакторът ви го поддържа, винаги работете в режим на показване на скритите символи. Преимуществата са:
      - По-лесно поддържане на консистентност
      - Премахване на интервалите в края на редовете
      - Премахване на празните редове с интервали
      - Commits и diffs се четат значително по-лесно
  - Използвайте [Editorconfig](http://editorconfig.org/) когато е възможно. Той се поддържа от повечето IDE-та и се грижи за повечето настройки на отстоянията.


2. <a name="spacing">Красив синтаксис</a>

    A. Скоби и разделители

    ```javascript

    // if/else/for/while/try винаги имат отстояния, скобите и span са многоредови
    // то придава повече четимост

    // 2.A.1.1
    // Примери на трудно четим синтаксис

    if( условие ) doSomething();

    while( условие ) iterating++;

    for(var i=0;i<100;i++) someIterativeFn();


    // 2.A.1.1
    // Използвайте отстояния за повече четимост

    if ( условие ) {
      // функционален код
    }

    while ( условие ) {
      // функционален код
    }

    for ( var i = 0; i < 100; i++ ) {
      // функционален код
    }

    // Дори по-добре:

    var i,
      length = 100;

    for ( i = 0; i < length; i++ ) {
      // функционален код
    }

    // Или...

    var i = 0,
      length = 100;

    for ( ; i < length; i++ ) {
      // функционален код
    }

    var prop;

    for ( prop in object ) {
      // функционален код
    }


    if ( true ) {
      // функционален код
    } else {
      // функционален код
    }
    ```

    B. Заявления, Декларации, Функции ( Именуване, Изрази, Конструктори )

    ```javascript

    // 2.B.1.1
    // Променливи
    var foo = "bar",
      num = 1,
      undef;

    // Буквални декларации
    var array = [],
      object = {};


    // 2.B.1.2
    // Използването само на един `var` за всеки scope (функция) или на един `var` за всяка променлива,
    // придава четимост и поддържа кода чист.
    // Ако използвате `var` пред всяка променлива, можете да контролирате по-добре версиите си
    // и реорганизирането по редове е значително по-лесно.
    // Един `var` за всеки scope прави по-лесно откриването на недекларирани променливи
    // които в противен случай, ще останат глобални.
    // Изберете предварително как ще работите и се придържайте към избора си. 

    // Лош пример
    var foo = "",
      bar = "";
    var qux;

    // Добър пример
    var foo = "";
    var bar = "";
    var qux;

    // или..
    var foo = "",
      bar = "",
      qux;

    // или..
    var // Коментар тук
    foo = "",
    bar = "",
    quux;

    // 2.B.1.3
    // var заявленията трябва винаги да се случват в началото на техния scope (функцията).


    // Лош пример
    function foo() {

      // функционален код

      var bar = "",
        qux;
    }

    // Добър пример
    function foo() {
      var bar = "",
        qux;

      // функционалния код е след декларирането на променливите.
    }

    // 2.B.1.4
    // const и let, от ECMAScript 6, също трябва да се заявяват в началото на техния scope (block).

    // Лош пример
    function foo() {
      let foo,
        bar;
      if ( condition ) {
        bar = "";
        // функционален код
      }
    }
    // Good
    function foo() {
      let foo;
      if ( condition ) {
        let bar = "";
        // функционален код
      }
    }
    ```

    ```javascript

    // 2.B.2.1
    // Деклариране на функции с имена
    function foo( arg1, argN ) {

    }

    // Употреба
    foo( arg1, argN );


    // 2.B.2.2
    // Деклариране на функции с имена
    function square( number ) {
      return number * number;
    }

    // Употреба
    square( 10 );

    // Доста "извратен" стил за предаване на параметри
    function square( number, callback ) {
      callback( number * number );
    }

    square( 10, function( square ) {
      // callback заявления
    });


    // 2.B.2.3
    // Функционални изрази
    var square = function( number ) {
      // Връща стойност или нещо релевантно
      return number * number;
    };

    // Функционални изрази с идентификатор
    var factorial = function factorial( number ) {
      if ( number < 2 ) {
        return 1;
      }

      return number * factorial( number - 1 );
    };


    // 2.B.2.4
    // Деклариране на конструктури
    function FooBar( options ) {

      this.options = options;
    }

    // Употреба
    var fooBar = new FooBar({ a: "alpha" });

    fooBar.options;
    // { a: "alpha" }

    ```


    C. Exceptions, Slight Deviations

    ```javascript

    // 2.C.1.1
    // Функции с callback
    foo(function() {
      // Забележете, че има допълнителен интервал преди първата скоба
      // на функцията и думата "function"
    });

    // Функция с параметър масив, без интервали
    foo([ "alpha", "beta" ]);

    // 2.C.1.2
    // Функция с параметър обект, без интервали
    foo({
      a: "alpha",
      b: "beta"
    });

    // Един аргумент, без интервали
    foo("bar");

    // Условни скоби, без интервали
    if ( !("foo" in obj) ) {
      obj = (obj.bar || defaults).baz;
    }

    ```

    D. Последователността винаги печели

    В секции 2.A-2.C, правилата за отстояния са препоръчителни за поддържане на консистентност при писането на код.
    Важно е да се отбележи, че препоръките за форматиране на код, като "вътрешни отстояния" са опционални, но поддържането на еднообразен стил за целия проект е от съществено значение.

    ```javascript

    // 2.D.1.1

    if (условие) {
      // заявления
    }

    while (условие) {
      // заявления
    }

    for (var i = 0; i < 100; i++) {
      // заявления
    }

    if (true) {
      // заявления
    } else {
      // заявления
    }

    ```

    E. Кавички

    За JavaScript няма никакво значение дали ще използвате единични или двойни кавички. Това, което **НАИСТИНА ИМА ЗНАЧЕНИЕ** е да бъдете последователни. **Никога не смесвайте кавичките в един и същ проект. Изберете стил и се придържайте към него.**

    F. Край на редове и празни редове

    Отстоянията могат да напарвят кода невъзможен за четене. Помислете дали да не включите употребата от pre-commit hook който да премахва интервалите в края на редовете и празните редове автоматично.

3. <a name="type">Правопис (Courtesy jQuery Core Style Guidelines)</a>

    A. Реални типове данни

    Низове:

        typeof variable === "string"

    Числа:

        typeof variable === "number"

    Булеви данни:

        typeof variable === "boolean"

    Обекти:

        typeof variable === "object"

    Масиви:

        Array.isArray( arrayLikeObject )
        (където е необходимо)

    Нодове:

        elem.nodeType === 1

    null:

        variable === null

    null или undefined:

        variable == null

    undefined:

      Глобални променливи:

        typeof variable === "undefined"

      Локални променливи:

        variable === undefined

      Характеристики:

        object.prop === undefined
        object.hasOwnProperty( prop )
        "prop" in object

    B. Coerce типове

    Да вземем следния пример...

    Даден е този HTML:

    ```html

    <input type="text" id="foo-input" value="1">

    ```


    ```javascript

    // 3.B.1.1

    // `foo` е променлива, декларирана със стойност `0` и тип `number`
    var foo = 0;

    // typeof foo;
    // "number"
    ...

    // По-натам в кода, се налага да промените стойността на `foo`
    // с нова стойност, която идва от input елемент

    foo = document.getElementById("foo-input").value;

    // Ако сега тествате типа на променливата `typeof foo`, резултатът ще е `string`
    // Това означава, че ако имате логика, която тества `foo` така:

    if ( foo === 1 ) {

      importantTask();

    }

    // `importantTask()` никога няма да бъде изпълнена, въпреки че `foo` има стойност "1"


    // 3.B.1.2

    // Можете да решите проблема като използвате smart coercion с унарните + или - оператори:

    foo = +document.getElementById("foo-input").value;
    //    ^ унарен + оператор автоматично ще конвертира дясната страна до number тип

    // И сега typeof foo;
    // "number"

    if ( foo === 1 ) {

      importantTask();

    }

    // `importantTask()` ще бъде изпълнена
    ```

    Ето няколко често срещани варианти на този тип:


    ```javascript

    // 3.B.2.1

    var number = 1,
      string = "1",
      bool = false;

    number;
    // 1

    number + "";
    // "1"

    string;
    // "1"

    +string;
    // 1

    +string++;
    // 1

    string;
    // 2

    bool;
    // false

    +bool;
    // 0

    bool + "";
    // "false"
    ```


    ```javascript
    // 3.B.2.2

    var number = 1,
      string = "1",
      bool = true;

    string === number;
    // false

    string === number + "";
    // true

    +string === number;
    // true

    bool === number;
    // false

    +bool === number;
    // true

    bool === string;
    // false

    bool === !!string;
    // true
    ```

    ```javascript
    // 3.B.2.3

    var array = [ "a", "b", "c" ];

    !!~array.indexOf("a");
    // true

    !!~array.indexOf("b");
    // true

    !!~array.indexOf("c");
    // true

    !!~array.indexOf("d");
    // false

    // Забалежете, че горните примери се квалифицират като "ненужно умен подход"
    // Винаги предпочитайте очевините подходи за сравняване
    // indexOf, като:

    if ( array.indexOf( "a" ) >= 0 ) {
      // ...
    }
    ```

    ```javascript
    // 3.B.2.4


    var num = 2.5;

    parseInt( num, 10 );

    // е същото като...

    ~~num;

    num >> 0;

    num >>> 0;

    // Всички резултати в 2


    // Не забравяйте, че отрицателните числа се третират различно...

    var neg = -2.5;

    parseInt( neg, 10 );

    // е същото като...

    ~~neg;

    neg >> 0;

    // Всички резултати в -2
    // Обаче...

    neg >>> 0;

    // Ще върне 4294967294




    ```



4. <a name="cond">Условни Оценки</a>

    ```javascript

    // 4.1.1
    // When only evaluating that an array has length,
    // instead of this:
    if ( array.length > 0 ) ...

    // ...evaluate truthiness, like this:
    if ( array.length ) ...


    // 4.1.2
    // When only evaluating that an array is empty,
    // instead of this:
    if ( array.length === 0 ) ...

    // ...evaluate truthiness, like this:
    if ( !array.length ) ...


    // 4.1.3
    // When only evaluating that a string is not empty,
    // instead of this:
    if ( string !== "" ) ...

    // ...evaluate truthiness, like this:
    if ( string ) ...


    // 4.1.4
    // When only evaluating that a string _is_ empty,
    // instead of this:
    if ( string === "" ) ...

    // ...evaluate falsy-ness, like this:
    if ( !string ) ...


    // 4.1.5
    // When only evaluating that a reference is true,
    // instead of this:
    if ( foo === true ) ...

    // ...evaluate like you mean it, take advantage of built in capabilities:
    if ( foo ) ...


    // 4.1.6
    // When evaluating that a reference is false,
    // instead of this:
    if ( foo === false ) ...

    // ...use negation to coerce a true evaluation
    if ( !foo ) ...

    // ...Be careful, this will also match: 0, "", null, undefined, NaN
    // If you _MUST_ test for a boolean false, then use
    if ( foo === false ) ...


    // 4.1.7
    // When only evaluating a ref that might be null or undefined, but NOT false, "" or 0,
    // instead of this:
    if ( foo === null || foo === undefined ) ...

    // ...take advantage of == type coercion, like this:
    if ( foo == null ) ...

    // Remember, using == will match a `null` to BOTH `null` and `undefined`
    // but not `false`, "" or 0
    null == undefined

    ```
    ALWAYS evaluate for the best, most accurate result - the above is a guideline, not a dogma.

    ```javascript

    // 4.2.1
    // Type coercion and evaluation notes

    // Prefer `===` over `==` (unless the case requires loose type evaluation)

    // === does not coerce type, which means that:

    "1" === 1;
    // false

    // == does coerce type, which means that:

    "1" == 1;
    // true


    // 4.2.2
    // Booleans, Truthies & Falsies

    // Booleans:
    true, false

    // Truthy:
    "foo", 1

    // Falsy:
    "", 0, null, undefined, NaN, void 0

    ```


5. <a name="practical">Practical Style</a>

    ```javascript

    // 5.1.1
    // A Practical Module

    (function( global ) {
      var Module = (function() {

        var data = "secret";

        return {
          // This is some boolean property
          bool: true,
          // Some string value
          string: "a string",
          // An array property
          array: [ 1, 2, 3, 4 ],
          // An object property
          object: {
            lang: "en-Us"
          },
          getData: function() {
            // get the current value of `data`
            return data;
          },
          setData: function( value ) {
            // set the value of `data` and return it
            return ( data = value );
          }
        };
      })();

      // Other things might happen here

      // expose our module to the global object
      global.Module = Module;

    })( this );

    ```

    ```javascript

    // 5.2.1
    // A Practical Constructor

    (function( global ) {

      function Ctor( foo ) {

        this.foo = foo;

        return this;
      }

      Ctor.prototype.getFoo = function() {
        return this.foo;
      };

      Ctor.prototype.setFoo = function( val ) {
        return ( this.foo = val );
      };


      // To call constructor's without `new`, you might do this:
      var ctor = function( foo ) {
        return new Ctor( foo );
      };


      // expose our constructor to the global object
      global.ctor = ctor;

    })( this );

    ```



6. <a name="naming">Naming</a>



    A. You are not a human code compiler/compressor, so don't try to be one.

    The following code is an example of egregious naming:

    ```javascript

    // 6.A.1.1
    // Example of code with poor names

    function q(s) {
      return document.querySelectorAll(s);
    }
    var i,a=[],els=q("#foo");
    for(i=0;i<els.length;i++){a.push(els[i]);}
    ```

    Without a doubt, you've written code like this - hopefully that ends today.

    Here's the same piece of logic, but with kinder, more thoughtful naming (and a readable structure):

    ```javascript

    // 6.A.2.1
    // Example of code with improved names

    function query( selector ) {
      return document.querySelectorAll( selector );
    }

    var idx = 0,
      elements = [],
      matches = query("#foo"),
      length = matches.length;

    for ( ; idx < length; idx++ ) {
      elements.push( matches[ idx ] );
    }

    ```

    A few additional naming pointers:

    ```javascript

    // 6.A.3.1
    // Naming strings

    `dog` is a string


    // 6.A.3.2
    // Naming arrays

    `dogs` is an array of `dog` strings


    // 6.A.3.3
    // Naming functions, objects, instances, etc

    camelCase; function and var declarations


    // 6.A.3.4
    // Naming constructors, prototypes, etc.

    PascalCase; constructor function


    // 6.A.3.5
    // Naming regular expressions

    rDesc = //;


    // 6.A.3.6
    // From the Google Closure Library Style Guide

    functionNamesLikeThis;
    variableNamesLikeThis;
    ConstructorNamesLikeThis;
    EnumNamesLikeThis;
    methodNamesLikeThis;
    SYMBOLIC_CONSTANTS_LIKE_THIS;

    ```

    B. Faces of `this`

    Beyond the generally well known use cases of `call` and `apply`, always prefer `.bind( this )` or a functional equivalent, for creating `BoundFunction` definitions for later invocation. Only resort to aliasing when no preferable option is available.

    ```javascript

    // 6.B.1
    function Device( opts ) {

      this.value = null;

      // open an async stream,
      // this will be called continuously
      stream.read( opts.path, function( data ) {

        // Update this instance's current value
        // with the most recent value from the
        // data stream
        this.value = data;

      }.bind(this) );

      // Throttle the frequency of events emitted from
      // this Device instance
      setInterval(function() {

        // Emit a throttled event
        this.emit("event");

      }.bind(this), opts.freq || 100 );
    }

    // Just pretend we've inherited EventEmitter ;)

    ```

    When unavailable, functional equivalents to `.bind` exist in many modern JavaScript libraries.


    ```javascript
    // 6.B.2

    // eg. lodash/underscore, _.bind()
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, _.bind(function( data ) {

        this.value = data;

      }, this) );

      setInterval(_.bind(function() {

        this.emit("event");

      }, this), opts.freq || 100 );
    }

    // eg. jQuery.proxy
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, jQuery.proxy(function( data ) {

        this.value = data;

      }, this) );

      setInterval( jQuery.proxy(function() {

        this.emit("event");

      }, this), opts.freq || 100 );
    }

    // eg. dojo.hitch
    function Device( opts ) {

      this.value = null;

      stream.read( opts.path, dojo.hitch( this, function( data ) {

        this.value = data;

      }) );

      setInterval( dojo.hitch( this, function() {

        this.emit("event");

      }), opts.freq || 100 );
    }

    ```

    As a last resort, create an alias to `this` using `self` as an Identifier. This is extremely bug prone and should be avoided whenever possible.

    ```javascript

    // 6.B.3

    function Device( opts ) {
      var self = this;

      this.value = null;

      stream.read( opts.path, function( data ) {

        self.value = data;

      });

      setInterval(function() {

        self.emit("event");

      }, opts.freq || 100 );
    }

    ```


    C. Use `thisArg`

    Several prototype methods of ES 5.1 built-ins come with a special `thisArg` signature, which should be used whenever possible

    ```javascript

    // 6.C.1

    var obj;

    obj = { f: "foo", b: "bar", q: "qux" };

    Object.keys( obj ).forEach(function( key ) {

      // |this| now refers to `obj`

      console.log( this[ key ] );

    }, obj ); // <-- the last arg is `thisArg`

    // Prints...

    // "foo"
    // "bar"
    // "qux"

    ```

    `thisArg` can be used with `Array.prototype.every`, `Array.prototype.forEach`, `Array.prototype.some`, `Array.prototype.map`, `Array.prototype.filter`

7. <a name="misc">Misc</a>

    This section will serve to illustrate ideas and concepts that should not be considered dogma, but instead exists to encourage questioning practices in an attempt to find better ways to do common JavaScript programming tasks.

    A. Using `switch` should be avoided, modern method tracing will blacklist functions with switch заявления

    There seems to be drastic improvements to the execution of `switch` заявления in latest releases of Firefox and Chrome.
    http://jsperf.com/switch-vs-object-literal-vs-module

    Notable improvements can be witnessed here as well:
    https://github.com/rwldrn/idiomatic.js/issues/13

    ```javascript

    // 7.A.1.1
    // An example switch statement

    switch( foo ) {
      case "alpha":
        alpha();
        break;
      case "beta":
        beta();
        break;
      default:
        // something to default to
        break;
    }

    // 7.A.1.2
    // A alternate approach that supports composability and reusability is to
    // use an object to store "cases" and a function to delegate:

    var cases, delegator;

    // Example returns for illustration only.
    cases = {
      alpha: function() {
        // заявления
        // a return
        return [ "Alpha", arguments.length ];
      },
      beta: function() {
        // заявления
        // a return
        return [ "Beta", arguments.length ];
      },
      _default: function() {
        // заявления
        // a return
        return [ "Default", arguments.length ];
      }
    };

    delegator = function() {
      var args, key, delegate;

      // Transform arguments list into an array
      args = [].slice.call( arguments );

      // shift the case key from the arguments
      key = args.shift();

      // Assign the default case handler
      delegate = cases._default;

      // Derive the method to delegate operation to
      if ( cases.hasOwnProperty( key ) ) {
        delegate = cases[ key ];
      }

      // The scope arg could be set to something specific,
      // in this case, |null| will suffice
      return delegate.apply( null, args );
    };

    // 7.A.1.3
    // Put the API in 7.A.1.2 to work:

    delegator( "alpha", 1, 2, 3, 4, 5 );
    // [ "Alpha", 5 ]

    // Of course, the `case` key argument could easily be based
    // on some other arbitrary condition.

    var caseKey, someUserInput;

    // Possibly some kind of form input?
    someUserInput = 9;

    if ( someUserInput > 10 ) {
      caseKey = "alpha";
    } else {
      caseKey = "beta";
    }

    // or...

    caseKey = someUserInput > 10 ? "alpha" : "beta";

    // And then...

    delegator( caseKey, someUserInput );
    // [ "Beta", 1 ]

    // And of course...

    delegator();
    // [ "Default", 0 ]


    ```

    B. Early returns promote code readability with negligible performance difference

    ```javascript

    // 7.B.1.1
    // Bad:
    function returnLate( foo ) {
      var ret;

      if ( foo ) {
        ret = "foo";
      } else {
        ret = "quux";
      }
      return ret;
    }

    // Good:

    function returnEarly( foo ) {

      if ( foo ) {
        return "foo";
      }
      return "quux";
    }

    ```


8. <a name="native">Native & Host Objects</a>

    The basic principle here is:

    ### Don't do stupid shit and everything will be ok.

    To reinforce this concept, please watch the following presentation:

    #### “Everything is Permitted: Extending Built-ins” by Andrew Dupont (JSConf2011, Portland, Oregon)

    http://www.everytalk.tv/talks/441-JSConf-Everything-is-Permitted-Extending-Built-ins


9. <a name="comments">Comments</a>

    #### Single line above the code that is subject
    #### Multiline is good
    #### End of line comments are prohibited!
    #### JSDoc style is good, but requires a significant time investment


10. <a name="language">One Language Code</a>

    Programs should be written in one language, whatever that language may be, as dictated by the maintainer or maintainers.

## Appendix

### Comma First.

Any project that cites this document as its base style guide will not accept comma first code formatting, unless explicitly specified otherwise by that project's author.



----------


<a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Principles of Writing Consistent, Idiomatic JavaScript</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/rwldrn/idiomatic.js" property="cc:attributionName" rel="cc:attributionURL">Rick Waldron and Contributors</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/rwldrn/idiomatic.js" rel="dct:source">github.com/rwldrn/idiomatic.js</a>.
